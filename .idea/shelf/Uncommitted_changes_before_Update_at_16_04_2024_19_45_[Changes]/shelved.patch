Index: Algorithms.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\nimport random\nimport sys\nimport time\nimport heapq\nimport queue\n\nfrom GraphClass import *\n\nclass EdgeRecord:\n    def __init__(self, u, v, ux, uy, vx, vy):\n        self.u = u\n        self.v = v\n        self.ux = ux\n        self.uy = uy\n        self.vx = vx\n        self.vy = vy\n\n\ndef Generate_Geometric_Graph(n, r, fileName):\n    print(\"--- starting generation ---\")\n    V = []\n    edgeRecord = set()\n    eR = set()\n    g = Graph()\n    for i in range(n):\n        x = random.uniform(0,1)\n        y = random.uniform(0,1)\n        vertex = Vertex(str(i), x, y)\n        V.append(vertex)\n        g.add_vertex(vertex)\n\n    #print(\"graph (just vertices):\", g.printGraph())\n    print(len(V), \" vertices generated\")\n    initU = \"-1\"\n    initV = \"-2\"\n    init_e_record = EdgeRecord(initU, initV, -1, -1, -1, -1)\n    edgeRecord.add(init_e_record)\n    for u in V:\n        for v in V:\n            if (u != v) and (((u.x - v.x)**2 + (u.y - v.y)**2) <= (r**2)):\n                #print(\"creating edge...\", u.name, v.name)\n                g.add_edge(u, v)\n                eRecord = EdgeRecord(u.name,v.name, u.x, u.y, v.x, v.y)\n                er = EdgeRecord(u.name,v.name, u.x, u.y, v.x, v.y)\n                eR.add(er)\n                isUniqueEdge = True\n                for e in edgeRecord:\n                    if (eRecord.u == e.u and eRecord.v == e.v) or (eRecord.u == e.v and eRecord.v == e.u):\n                        isUniqueEdge = False\n                if isUniqueEdge:\n                    edgeRecord.add(eRecord)\n\n    edgeRecord.remove(init_e_record)\n    verticesSet = set()\n    for eRecord in edgeRecord:\n        verticesSet.add(eRecord.u)\n        verticesSet.add(eRecord.v)\n    numVertices = len(verticesSet)\n    numEdges = len(edgeRecord)\n    print(\"writing #vertices: \",  numVertices)\n    print(\"writing #edges: \", numEdges)\n\n    file = open(fileName + \".edges\", \"w\")\n    file.write(\"% sym unweighted unsigned undirected\\n\")\n    file.write(\"% \" + str(numEdges) + \" \" + str(numVertices) + \" \" + str(numVertices) + \" \" + str(numVertices) + \"\\n\")\n    for record in edgeRecord:\n        #print(\"edge record u:\", record.u, \"(x:\", record.ux, \"y:\", record.uy,\") v:\" ,record.v, \"(x:\", record.vx, \"y:\", record.vy, \")\")\n        file.write(record.u + \" \" + str(record.ux) + \" \" + str(record.uy) + \" \" + record.v + \" \" + str(record.vx) + \" \" + str(record.vy) + \"\\n\")\n\n    #print(\"graph (with edges):\", g.printGraph())\n    print(\"--- end of generation ---\")\n\ndef Read_Geometric_Graph(fileName):\n    print(\"--- starting reading:\", fileName,\" ---\")\n    startTimer = time.time()\n\n    g = Graph()\n    vertexDict = {}\n    vNames = []\n\n    file = open(fileName, \"r\")\n    idx = 0\n    for data in file:\n        if idx >= 2:\n            content = data.split()\n            #get data\n            uName = content[0]\n            uX = content[1]\n            uY = content[2]\n            vName = content[3]\n            vX = content[4]\n            vY = content[5]\n\n            if uName not in vNames:\n                u = Vertex(uName, uX, uY)\n                vNames.append(uName)\n                vertexDict[uName] = u\n            if vName not in vNames:\n                v = Vertex(vName, vX, vY)\n                vNames.append(vName)\n                vertexDict[vName] = v\n        idx += 1\n    file.close()\n\n    file = open(fileName, \"r\")\n    idx = 0\n    for data in file:\n        if idx >= 2:\n            content = data.split()\n            # get data\n            uName = content[0]\n            vName = content[3]\n            g.add_edge(vertexDict[uName], vertexDict[vName])\n        idx += 1\n    file.close()\n    print(\"number of vertices: \", len(g.vertices))\n    print(\"vertex dict length:\" , len(vertexDict))\n    print(\"--- end of reading ---\")\n    return g\n\ndef Read_Online_Graph(fileName, startingIndex):\n    print(\"--- starting reading:\", fileName,\" ---\")\n    g = Graph()\n    vertexDict = {}\n    verticeNames = set()\n    file = open(fileName, \"r\")\n    idx = 0\n    # read and create vertices\n    for data in file:\n        if idx >= startingIndex:\n            # read edges\n            content = data.split()\n            # get data\n            uName = content[0]\n            vName = content[1]\n            if uName not in verticeNames:\n                u = Vertex(uName,0,0)\n                verticeNames.add(uName)\n                vertexDict[uName] = u\n            if vName not in verticeNames:\n                v = Vertex(vName,0,0)\n                verticeNames.add(vName)\n                vertexDict[vName] = v\n        idx += 1\n    file.close()\n\n    #create edges by using previously created vertices\n    file = open(fileName, \"r\")\n    idx = 0\n    for data in file:\n        if idx >= startingIndex:\n            # read edges\n            content = data.split()\n            # get data\n            uName = content[0]\n            vName = content[1]\n            g.add_edge(vertexDict[uName], vertexDict[vName])\n        idx += 1\n    file.close()\n    print(\"--- end of reading ---\")\n    return g\n\ndef DFS(g, startingVertex):\n    # initialization\n    for u in g.vertices:\n        g.setColor(u, \"white\")\n        g.setPi(u, \"nil\")\n    time = 0\n    if g.getColor()[startingVertex] == \"white\":\n        DFS_Visit(g, startingVertex, time)\n\n\ndef DFS_Visit(g, vertexKey, time):\n    time += 1\n    g.setD(vertexKey, time)\n    g.setColor(vertexKey, \"gray\")\n    for neighborKey in g.vertices[vertexKey]:\n        if g.getColor()[neighborKey] == \"white\":\n            g.setPi(neighborKey, vertexKey)\n            DFS_Visit(g, neighborKey, time)\n    time += 1\n    g.setF(vertexKey, time)\n    g.setColor(vertexKey, \"black\")\n\ndef CalculateLCC(g):\n    cc = []\n    # initialization\n    for u in g.vertices:\n        g.setColor(u, \"white\")\n    # starting for dfs\n    for v in g.vertices:\n        if g.getColor()[v] == \"white\":\n            tmp = []\n            cc.append(DfsVisitCC(g, tmp, v))\n\n    ## cc = list consisting of connected components\n    lcc = []\n    for connectedComponents in cc:\n        if len(connectedComponents) > len(lcc):\n            lcc = connectedComponents\n    return lcc\n\ndef DfsVisitCC(g, tmp, vertexKey):\n    g.setColor(vertexKey, \"black\")\n    tmp.append(vertexKey)\n    for neighborKey in g.vertices[vertexKey]:\n        if g.getColor()[neighborKey] == \"white\":\n            tmp = DfsVisitCC(g, tmp, neighborKey)\n    return  tmp\n\ndef TestingLCC():\n    testG = Graph()\n    a = Vertex(\"A\", 0, 0)\n    b = Vertex(\"B\", 0, 1)\n    c = Vertex(\"C\", 0, 2)\n    d = Vertex(\"D\", 0, 3)\n    e = Vertex(\"E\", 0, 4)\n    f = Vertex(\"F\", 0, 5)\n    g = Vertex(\"G\", 1, 0)\n    h = Vertex(\"H\", 2, 0)\n    j = Vertex(\"J\", 3, 0)\n    testG.add_vertices([a, b, c, d, e, f, g, h, j])\n    testG.add_edge(a, b)\n    testG.add_edge(b, c)\n    testG.add_edge(c, e)\n    testG.add_edge(d, f)\n    testG.add_edge(f, g)\n    testG.add_edge(g, h)\n    testG.add_edge(h, j)\n    print(\"--- LCC TESTING ---\")\n    print(\"graph: \",testG.printGraph())\n    LCC = CalculateLCC(testG)\n    print(\"LCC: \", LCC)\n    print(\"--- END of LCC TESTING ---\")\n\ndef Print_Simulation_Results(g):\n    print(\"-- SIMULATION RESULTS --\")\n    graphLcc = CalculateLCC(g)\n    vLcc = len(graphLcc)\n    print(\"numberOfVertices:\", len(g.vertices))\n    print(\"vLcc: \", vLcc)\n    deltaLcc = 0\n    kLcc = 0\n    sum_kV = 0\n    for v in graphLcc:\n        kV = len(g.vertices[v])\n        sum_kV += kV\n        if kV >= deltaLcc:\n            deltaLcc = kV\n    kLcc = (1 / vLcc) * sum_kV\n    print(\"deltaLcc(maximum degree of nodes in LCC):\", deltaLcc)\n    print(\"kLcc(average degree of nodes in LCC): \", kLcc)\n    print(\"LCC Graph: \",graphLcc)\n\n    print(\"-- END OF SIMULATION RESULTS --\")\n\ndef DFS_Based_Longest_Simple_Path(g):\n    print(\"--- DFS Based Longest Simple Path ---\")\n    graphLcc = CalculateLCC(g)\n    vLcc = len(graphLcc)\n    Lmax = 0\n    print(\"DFS will be run \", math.sqrt(vLcc), \"times\")\n    for i in range(int(math.sqrt(vLcc)) + 1):\n        print(\"DFS #\", i)\n        # selecting random vertex\n        randomVertex = random.choice(graphLcc)\n        # apply dfs\n        DFS(g, randomVertex)\n        # finding the key and value for the greatest depth vertex\n        max_d_key_for_randomVertex = Get_Largest_D_Key(g, randomVertex)\n        max_d_for_randomVertex = g.getD(max_d_key_for_randomVertex)\n\n        # applying dfs by starting from the greatest depth vertex found before\n        DFS(g, max_d_key_for_randomVertex)\n        # finding the key and value for this dfs\n        max_d_key_for_otherVertex = Get_Largest_D_Key(g, max_d_key_for_randomVertex)\n        max_d_for_otherVertex = g.getD(max_d_key_for_otherVertex)\n\n        # Lmax\n        Lmax = max(Lmax, max_d_for_randomVertex, max_d_for_otherVertex)\n    print(\"For DFS Based, Lmax: \", Lmax)\n    print(\"--- End of DFS Based Longest Simple Path ---\")\n\ndef Get_Largest_D_Key(g, startingVertexKey):\n    max_d_key = startingVertexKey\n    max_d = g.getD(max_d_key)\n    for v in g.vertices:\n        if g.getD(v) >= max_d and g.getD(v) != math.inf:\n            max_d_key = v\n            max_d = g.getD(max_d_key)\n    return max_d_key\n\ndef Get_A_Source_Node(g):\n    graphSize = len(g.vertices)\n    number = random.randint(0, graphSize)\n    index = 0\n    for v in g.vertices:\n        index += 1\n        if index == number:\n            return v\n\ndef Initialize_Single_Source_Max(g, sKey):\n    for v in g.vertices:\n        g.setD(v, -math.inf)\n        g.setPi(v, \"nil\")\n    g.setD(sKey,0)\n\ndef Relax_Max(g, uKey, vKey):\n    if g.getD(vKey) < g.getD(uKey) + 1:\n        newD = g.getD(uKey) + 1\n        g.setD(vKey, newD)\n        g.setPi(vKey, uKey)\n        return True\n    else:\n        return False\n\ndef Dijskstra_Max(g, sKey):\n    Initialize_Single_Source_Max(g, sKey)\n    S = set()\n    Q = []\n    # distance, key\n    for u in g.vertices:\n        heappush_max(Q, (g.getD(str(u)), int(u)))\n    while Q:\n        ud, u = heapq._heappop_max(Q)\n        S.add(str(u))\n        #print(\"S: \", S)\n        #print(\"calculating for adjacent nodes of vertex: \", u)\n        for v in g.vertices[str(u)]:\n            #print(\"previous d: \",g.getD(v))\n            if v in S:\n                #print(v,\" is in S!\")\n                continue\n            #print(\"Q:\",Q)\n            index = Q.index((g.getD(str(v)), int(v)))\n            result = Relax_Max(g, str(u), str(v))\n            if result == True:\n                Q[index] = (g.getD(str(v)), int(v)) # increase key\n                heapq._heapify_max(Q)\n    # below for debug purposes\n    #print(\"results:\")\n    #print(\"source node: \", sKey)\n    #for v in g.vertices:\n        #print(\"vertex:\", v, \" v.d:\", g.getD(v), \" v.pi: \", g.getPi(v))\n\ndef heappush_max(max_heap, item):\n    max_heap.append(item)\n    heapq._siftdown_max(max_heap, 0, len(max_heap)-1)\n\ndef Dijkstra_Based_Longest_Simple_Path(g):\n    print(\"--- Dijkstra Based Longest Simple Path ---\")\n    # we follow a similar approach with dfs longest simple path\n    graphLcc = CalculateLCC(g)\n    vLcc = len(graphLcc)\n    Lmax = 0\n    print(\"Dijkstra will be run \", math.sqrt(vLcc) + 1 , \" times\")\n    for i in range(int(math.sqrt(vLcc)) + 1):\n        print(\"Dijkstra #\", i)\n        # select random vertex\n        randomVert = random.choice(graphLcc)\n        # apply dijsktra\n        Dijskstra_Max(g, randomVert)\n        # find the key and value for largest d vertex\n        max_d_key_for_randomVert = Get_Largest_D_Key(g, randomVert)\n        max_d_for_randomVert = g.getD(max_d_key_for_randomVert)\n\n        # this time apply dijsktra with the vertex found that was the largest d in previous run\n        Dijskstra_Max(g, max_d_key_for_randomVert)\n        # find the key and value for largest d vertex for the second dijkstra run\n        max_d_key_for_secondRun = Get_Largest_D_Key(g, max_d_key_for_randomVert)\n        max_d_for_secondRun = g.getD(max_d_key_for_secondRun)\n\n        # calculate Lmax\n        Lmax = max(Lmax, max_d_for_randomVert, max_d_for_secondRun)\n    print(\"For Dijkstra Based, Lmax:\", Lmax)\n    print(\"--- End of Dijkstra Based Longest Simple Path ---\")\n\ndef A_Star(g, sourceKey, destinationKey):\n    print(\"- A* -\")\n    Initialize_Single_Source_Max(g, sourceKey)\n    for v in g.vertices:\n        dX = float(g.getXposition(destinationKey))\n        vX = float(g.getXposition(v))\n        dY = float(g.getYposition(destinationKey))\n        vY = float(g.getYposition(v))\n        hVal = math.sqrt((dX - vX)**2 + (dY - vY)**2)\n        g.setH(v, hVal)\n    S = set()\n    Q = []\n    for u in g.vertices:\n        dh = g.getD(str(u)) + g.getH(str(u))\n        heappush_max(Q, (dh, int(u)))\n    #print(\"Q: \", Q)\n    while Q:\n        _, u = heapq._heappop_max(Q)\n        S.add(str(u))\n        #print(\"S: \", S)\n        #print(\"calculating for \", u)\n        for v in g.vertices[str(u)]:\n            if v in S:\n                continue\n            dh = g.getD(str(v)) + g.getH(str(v))\n            #print(\"dh: \", dh, \"type: \", type(dh))\n            #print(\"Q:\", Q)\n            index = Q.index((dh, int(v)))\n            result = Relax_Max(g, str(u), str(v))\n            if result:\n                #print(\"vd is increased\")\n                if v in S:\n                    #print(\"v is in S\")\n                    S.remove(v)\n                    dh = g.getD(str(v)) + g.getH(str(v))\n                    heappush_max(Q, (dh, int(v)))\n                elif v not in S:\n                    #print(\"v is not in S\")\n                    dh = g.getD(str(v)) + g.getH(str(v))\n                    Q[index] = (dh, int(v))\n                    heapq._heapify_max(Q)\n    print(\"- End of A* -\")\n\ndef A_Star_Based_Longest_Simple_Path(g):\n    print(\"--- A* Based Longest Simple Path ---\")\n    # we follow a similar approach with dfs longest simple path\n    graphLcc = CalculateLCC(g)\n    vLcc = len(graphLcc)\n    Lmax = 0\n    for i in range(int(math.sqrt(vLcc)) + 1):\n        # select random source and destination nodes\n        s1 = random.choice(graphLcc)\n        d1 = random.choice(graphLcc)\n        while s1 == d1:\n            d1 = random.choice(graphLcc)\n        # run a*\n        A_Star(g, s1, d1)\n        # find the key and value for largest d vertex\n        max_d_key_opt1 = Get_Largest_D_Key(g, s1)\n        max_d_opt1 = g.getD(max_d_key_opt1)\n\n        # run a* again, start with the vertex having largest d from previous run\n        # select a random destination\n        d2 = random.choice(graphLcc)\n        while d2 == max_d_key_opt1:\n            d2 = random.choice(graphLcc)\n        # run a*\n        A_Star(g, max_d_key_opt1, d2)\n        # find the key and value for largest d vertex\n        max_d_key_opt2 = Get_Largest_D_Key(g, max_d_key_opt1)\n        max_d_opt2 = g.getD(max_d_key_opt2)\n\n        #calculate Lmax\n        Lmax = max(Lmax, max_d_opt1, max_d_opt2)\n    print(\"For A* Based, Lmax:\", Lmax)\n    print(\"--- End of A* Based Longest Simple Path ---\")\n\ndef BFS_Modified(g, sKey, usedKeys):\n    for u in g.vertices:\n        if u in usedKeys:\n            continue\n        g.setColor(u, \"white\")\n        g.setD(u, math.inf)\n        g.setPi(u, \"nil\")\n    g.setColor(sKey, \"gray\")\n    g.setD(sKey,0)\n    g.setPi(sKey, \"nil\")\n    Q = queue.Queue() # first in first out queue, keys will be stored inside of it\n    Q.put(sKey)\n    while Q.qsize() > 0:\n        uKey = Q.get()\n        for vKey in g.vertices[str(uKey)]:\n            if g.getColor()[vKey] == \"white\":\n                g.setColor(vKey, \"gray\")\n                newD = g.getD(uKey) + 1\n                g.setD(vKey, newD)\n                g.setPi(vKey, uKey)\n                Q.put(vKey)\n        g.setColor(uKey, \"black\")\n\ndef BFS(g, sKey):\n    for u in g.vertices:\n        g.setColor(u, \"white\")\n        g.setD(u, math.inf)\n        g.setPi(u, \"nil\")\n    g.setColor(sKey, \"gray\")\n    g.setD(sKey,0)\n    g.setPi(sKey, \"nil\")\n    Q = queue.Queue() # first in first out queue, keys will be stored inside of it\n    Q.put(sKey)\n    while Q.qsize() > 0:\n        uKey = Q.get()\n        for vKey in g.vertices[str(uKey)]:\n            if g.getColor()[vKey] == \"white\":\n                g.setColor(vKey, \"gray\")\n                newD = g.getD(uKey) + 1\n                g.setD(vKey, newD)\n                g.setPi(vKey, uKey)\n                Q.put(vKey)\n        g.setColor(uKey, \"black\")\n\n\ndef BFS_Heuristic_With_Rememberization(g):\n    print(\"--- BFS Based Longest Simple Path With Rememberization ---\")\n    # we follow a similar approach with dfs longest simple path\n    graphLcc = CalculateLCC(g)\n    vLcc = len(graphLcc)\n    Lmax = 0\n    usedKeys = []\n    print(\"BFS Heuristic With Rememberization will be called #\",2*len(graphLcc),\" times\")\n    numTimes = 0\n    for v in graphLcc:\n        numTimes += 1\n        print(\"BFS Heuristic #\", numTimes)\n        BFS_Modified(g, v, usedKeys)\n        usedKeys.append(v)\n        max_d_key = Get_Largest_D_Key(g,v)\n        numTimes += 1\n        print(\"BFS Heuristic #\", numTimes)\n        BFS_Modified(g, max_d_key, usedKeys)\n        max_d_key_2 = Get_Largest_D_Key(g,max_d_key)\n        Lmax = max(Lmax, g.getD(max_d_key), g.getD(max_d_key_2))\n    print(\"For BFS Heuristic With Rememberization, Lmax:\", Lmax)\n\ndef BFS_Longest_Normal(g):\n    print(\"--- BFS Based Longest Simple Path ---\")\n    # we follow a similar approach with dfs longest simple path\n    graphLcc = CalculateLCC(g)\n    Lmax = 0\n    numTimes = 0\n    print(\"BFS Heuristic (normal) will be called #\", 2 * len(graphLcc), \" times\")\n    for v in graphLcc:\n        numTimes += 1\n        print(\"BFS Heuristic #\", numTimes)\n        BFS(g, v)\n        max_d_key = Get_Largest_D_Key(g, v)\n        numTimes += 1\n        print(\"BFS Heuristic #\", numTimes)\n        BFS(g, max_d_key)\n        max_d_key_2 = Get_Largest_D_Key(g, max_d_key)\n        Lmax = max(Lmax, g.getD(max_d_key), g.getD(max_d_key_2))\n    print(\"For Normal BFS Heuristic, Lmax:\", Lmax)\n# testing field\n#fileName = \"graph_6_n_500_r_0_055\"\n#Generate_Geometric_Graph(100, 0.15, fileName)\n#graph = Read_Geometric_Graph(fileName+\".edges\")\n#Print_Simulation_Results(graph)\n#DFS_Based_Longest_Simple_Path(graph)\n#Dijkstra_Based_Longest_Simple_Path(graph)\n#A_Star_Based_Longest_Simple_Path(graph)\n#BFS_Heuristic_With_Rememberization(graph)\n#BFS_Longest_Normal(graph)\n\n#onlineGraph = Read_Online_Graph(\"inf-power.mtx\",3)\n#Print_Simulation_Results(onlineGraph)\n#sys.setrecursionlimit(2000)\n#DFS_Based_Longest_Simple_Path(onlineGraph)\n#Dijkstra_Based_Longest_Simple_Path(onlineGraph)\n#BFS_Heuristic_With_Rememberization(onlineGraph)\n#BFS_Longest_Normal(onlineGraph)\n\nonlineGraph = Read_Online_Graph(\"DSJC500-5.mtx\", 2)\nPrint_Simulation_Results(onlineGraph)\n#DFS_Based_Longest_Simple_Path(onlineGraph)\n#Dijkstra_Based_Longest_Simple_Path(onlineGraph)\n#BFS_Heuristic_With_Rememberization(onlineGraph)\n#BFS_Longest_Normal(onlineGraph)\n\n#onlineGraph = Read_Online_Graph(\"inf-euroroad.edges\",2)\n#Print_Simulation_Results(onlineGraph)\n#DFS_Based_Longest_Simple_Path(onlineGraph)\n#Dijkstra_Based_Longest_Simple_Path(onlineGraph)\n#BFS_Longest_Normal(onlineGraph)\n#BFS_Heuristic_With_Rememberization(onlineGraph)\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Algorithms.py b/Algorithms.py
--- a/Algorithms.py	(revision 2305de373dcbc96e14fc529b05cb3377b8f0a074)
+++ b/Algorithms.py	(date 1713237650584)
@@ -539,10 +539,10 @@
         Lmax = max(Lmax, g.getD(max_d_key), g.getD(max_d_key_2))
     print("For Normal BFS Heuristic, Lmax:", Lmax)
 # testing field
-#fileName = "graph_6_n_500_r_0_055"
+fileName = "graph_6_n_500_r_0_055"
 #Generate_Geometric_Graph(100, 0.15, fileName)
-#graph = Read_Geometric_Graph(fileName+".edges")
-#Print_Simulation_Results(graph)
+graph = Read_Geometric_Graph(fileName+".edges")
+Print_Simulation_Results(graph)
 #DFS_Based_Longest_Simple_Path(graph)
 #Dijkstra_Based_Longest_Simple_Path(graph)
 #A_Star_Based_Longest_Simple_Path(graph)
@@ -557,8 +557,8 @@
 #BFS_Heuristic_With_Rememberization(onlineGraph)
 #BFS_Longest_Normal(onlineGraph)
 
-onlineGraph = Read_Online_Graph("DSJC500-5.mtx", 2)
-Print_Simulation_Results(onlineGraph)
+#onlineGraph = Read_Online_Graph("DSJC500-5.mtx", 2)
+#Print_Simulation_Results(onlineGraph)
 #DFS_Based_Longest_Simple_Path(onlineGraph)
 #Dijkstra_Based_Longest_Simple_Path(onlineGraph)
 #BFS_Heuristic_With_Rememberization(onlineGraph)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"f1ec7563-1a45-4d2a-a72c-39f3318e71c6\" name=\"Changes\" comment=\"project files\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Algorithms.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Algorithms.py\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"ProjectColorInfo\"><![CDATA[{\n  \"associatedIndex\": 8\n}]]></component>\n  <component name=\"ProjectId\" id=\"2f9wMUtAhky6dPNL08pPxhKoOHF\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Python.Algorithms.executor\": \"Run\",\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"git-widget-placeholder\": \"main\"\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n    </key>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-python-sdk-5a2391486177-d3b881c8e49f-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-233.13763.11\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"f1ec7563-1a45-4d2a-a72c-39f3318e71c6\" name=\"Changes\" comment=\"\" />\n      <created>1713226553977</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1713226553977</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"initial commit\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1713226797584</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1713226797584</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"second commit\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1713226989062</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1713226989062</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"project files\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1713227211677</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1713227211677</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"project files\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1713227248896</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1713227248896</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"5\" />\n    <servers />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"initial commit\" />\n    <MESSAGE value=\"second commit\" />\n    <MESSAGE value=\"project files\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"project files\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 2305de373dcbc96e14fc529b05cb3377b8f0a074)
+++ b/.idea/workspace.xml	(date 1713237678289)
@@ -4,7 +4,7 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="f1ec7563-1a45-4d2a-a72c-39f3318e71c6" name="Changes" comment="project files">
+    <list default="true" id="f1ec7563-1a45-4d2a-a72c-39f3318e71c6" name="Changes" comment="april 15 version">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Algorithms.py" beforeDir="false" afterPath="$PROJECT_DIR$/Algorithms.py" afterDir="false" />
     </list>
@@ -23,23 +23,23 @@
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
-  <component name="ProjectColorInfo"><![CDATA[{
-  "associatedIndex": 8
-}]]></component>
+  <component name="ProjectColorInfo">{
+  &quot;associatedIndex&quot;: 8
+}</component>
   <component name="ProjectId" id="2f9wMUtAhky6dPNL08pPxhKoOHF" />
   <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Python.Algorithms.executor": "Run",
-    "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "main"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Python.Algorithms.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;main&quot;
   }
-}]]></component>
+}</component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
       <recent name="$PROJECT_DIR$" />
@@ -93,13 +93,22 @@
       <option name="project" value="LOCAL" />
       <updated>1713227248896</updated>
     </task>
-    <option name="localTasksCounter" value="5" />
+    <task id="LOCAL-00005" summary="april 15 version">
+      <option name="closed" value="true" />
+      <created>1713236873982</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1713236873982</updated>
+    </task>
+    <option name="localTasksCounter" value="6" />
     <servers />
   </component>
   <component name="VcsManagerConfiguration">
     <MESSAGE value="initial commit" />
     <MESSAGE value="second commit" />
     <MESSAGE value="project files" />
-    <option name="LAST_COMMIT_MESSAGE" value="project files" />
+    <MESSAGE value="april 15 version" />
+    <option name="LAST_COMMIT_MESSAGE" value="april 15 version" />
   </component>
 </project>
\ No newline at end of file
